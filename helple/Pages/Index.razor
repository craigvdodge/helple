@page "/"

<PageTitle>Helple</PageTitle>

<h1>Helple Word List</h1>

<div>
    <label>@ErrMsg</label>
    <label @onload="ReadWordsFile">@Message</label>
</div>
<div hidden="@hideGuessBtn">
    <button @onclick="OnGuessBtnClick">Enter Guess</button>
</div>
<div hidden="@hideGuessInput">
    <p>
    <label>Enter word to guess:</label>
    <input @bind="Guess" />
    </p>
    <button @onclick="OnGuessClick">Filter list based on results of guess</button>
</div>
<div hidden="@hideGuessColorPicker">
    <div>
        <label>@ColorCodingArray[0].Letter</label>
        <select @bind="cc0">
            @foreach (var value in Enum.GetValues<ColorCode>())
            {
                <option>@value.ToString()</option>
            }
        </select>
    </div>
    <div>
        <label>@ColorCodingArray[1].Letter</label>
        <select @bind="cc1">
            @foreach (var value in Enum.GetValues<ColorCode>())
            {
                <option>@value.ToString()</option>
            }
        </select>
    </div>
    <div>
        <label>@ColorCodingArray[2].Letter</label>
        <select @bind="cc2">
            @foreach (var value in Enum.GetValues<ColorCode>())
            {
                <option>@value.ToString()</option>
            }
        </select>
    </div>
    <div>
        <label>@ColorCodingArray[3].Letter</label>
        <select @bind="cc3">
            @foreach (var value in Enum.GetValues<ColorCode>())
            {
                <option>@value.ToString()</option>
            }
        </select>
    </div>
    <div>
        <label>@ColorCodingArray[4].Letter</label>
        <select @bind="cc4">
            @foreach (var value in Enum.GetValues<ColorCode>())
            {
                <option>@value.ToString()</option>
            }
        </select>
    </div>
    <button @onclick="OnColorCodeClick">Filter list</button>
</div>
<div>
    @if (@CurrentPage == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <p><button @onclick="@OnPageBack">previous</button>@PageHeader<button @onclick="@OnPageFwd">next</button></p>
        <table class="table">
            <tbody>
                @for (int i=0; i<CurrentPage.Count; i+=@Columns)
                {
                    <tr>
                        @for(int j=0; j<@Columns; j++)
                        {
                            @if (i+j >= CurrentPage.Count)
                            {
                                <td></td>
                            }
                            else
                            {
                                <td>@CurrentPage[i+j]</td>
                            }
                        }                       
                    </tr>    
                }
        </tbody>
    </table>
    }   
</div>

@inject HttpClient _client

@code {
    public const int Columns = 4;
    // This is hella stupid, but I couldn't figure out how to bind the dropdown refering to an array memember. Brute force ftw.
    public ColorCode cc0;
    public ColorCode cc1;
    public ColorCode cc2;
    public ColorCode cc3;
    public ColorCode cc4;

    // "select" means user has not entered color code yet
    public enum ColorCode
    {
        Select=0,
        Black,
        Yellow,
        Green
    }

    public class ColorCodingInfo
    {
        public ColorCodingInfo(string letter)
        {
            Letter = letter;
            Code = ColorCode.Select;
            Duplicates = new List<int>();
        }
        public string Letter { get; set; }
        public ColorCode Code { get; set; }
        public List<int> Duplicates { get; set; }
    }

    public ColorCodingInfo[] ColorCodingArray = InitColorCodingArray();

    public static ColorCodingInfo[] InitColorCodingArray()
    {
        ColorCodingInfo[] retval = new ColorCodingInfo[5];
        for (int i=0; i<5; i++)
        {
            retval[i] = new ColorCodingInfo(string.Empty);
        }

        return retval;
    }

    private string? Guess { get; set; }
    private void OnGuessClick()
    {

        if (Guess == null || Guess.Length != 5)
        {
            ErrMsg = "Guess must be 5 characters.";
            return;
        }
        Guess = Guess.ToUpper();
        // TODO: more checking here
        ErrMsg = null;
        hideGuessColorPicker = false;
        hideGuessInput = true;      

        // xfer Guess to ColorCodingInfo array
        for (int i=0; i<5; i++)
        {
            ColorCodingArray[i].Letter = Guess.Substring(i, 1);
            ColorCodingArray[i].Code = ColorCode.Select;
        }

    }
    private string? ErrMsg;
    private bool hideGuessColorPicker = true;
    private bool hideGuessInput = true;
    private bool hideGuessBtn = false;

    private void OnGuessBtnClick()
    {
        hideGuessBtn = true;
        hideGuessInput = false;
    }

    private void OnColorCodeClick()
    {
        // xfer codes from ccx variables to ColorCodingArray
        ColorCodingArray[0].Code = cc0;
        ColorCodingArray[1].Code = cc1;
        ColorCodingArray[2].Code = cc2;
        ColorCodingArray[3].Code = cc3;
        ColorCodingArray[4].Code = cc4;

        // Validation

        for (int i=0; i<5; i++)
        {
            if (ColorCodingArray[i].Code == ColorCode.Select)
            {
                ErrMsg = ColorCodingArray[i].Letter + " color not selected";
                return;
            }
        }

        // TODO: replace ErrMsg with Message
        ErrMsg = string.Empty;

        GuessDupLetScan();

        // Filter word list
        List<string> FilteredList = new List<string>(Wordlist);
        for (int i=0; i<5; i++)
        {
            List<string> NewFilteredList = FilteredWordList(FilteredList, ColorCodingArray[i], i);
            FilteredList = NewFilteredList;
        }
        Wordlist = FilteredList;
        CurrentPageNumber = 0;
        AllPages = Paginate(ref Wordlist);
        CurrentPage = AllPages[CurrentPageNumber];

        // Clean up 
        hideGuessColorPicker = true;
        hideGuessBtn = false;
        Guess = null;
        foreach (ColorCodingInfo cci in ColorCodingArray)
        {
            cci.Letter = string.Empty;
            cci.Code = ColorCode.Select;
            cci.Duplicates.Clear();
        }
        cc0 = ColorCode.Select;
        cc1 = ColorCode.Select;
        cc2 = ColorCode.Select;
        cc3 = ColorCode.Select;
        cc4 = ColorCode.Select;
        Message = string.Empty;
    }

    private void GuessDupLetScan()
    {
        for (int i=0; i<5; i++)
        {
            for (int j=0; j<5; j++)
            {
                if (i == j)
                {
                    continue;
                }
                if (ColorCodingArray[i].Letter == ColorCodingArray[j].Letter)
                {
                    ColorCodingArray[i].Duplicates.Add(j);
                }
            }
        }
    }

    private List<string> FilteredWordList(List<string> words, ColorCodingInfo cc, int index)
    {
        List<string> FilteredList = new List<string>();
        switch (cc.Code)
        {
            case ColorCode.Black:
                {
                    // Black: word does not contain this letter. Remove all words that have this letter.
                    foreach (string word in words)
                    {                           
                        if (!word.Contains(cc.Letter))
                        {
                            FilteredList.Add(word);
                        } 
                        else // Duplicate edge case: if letter is at dupe, pass through too.
                        {
                            foreach (int dupe in cc.Duplicates)
                            {
                                if (word[dupe] == cc.Letter[0])
                                {
                                    FilteredList.Add(word);
                                }
                            }
                        }
                    }
                    break;
                }
            case ColorCode.Yellow:
                {   
                    foreach (string word in words)
                    {
                        if (word.Contains(cc.Letter) && word[index] != cc.Letter[0])
                        {
                            FilteredList.Add(word);
                        }
                    }
                    break;
                }
            case ColorCode.Green:
                {
                    foreach (string word in words)
                    {
                        if (word.Substring(index, 1) == cc.Letter)
                        {
                            FilteredList.Add(word);
                        }
                    }
                    break;
                }
            case ColorCode.Select:
                {
                    throw new ArgumentException("Filtering not specified: " + cc.Letter);
                }

        }
        return FilteredList;
    }

    public List<string> Wordlist = new List<string>();
    public List<string>? CurrentPage = null;
    public List<List<string>>? AllPages = null;
    public int CurrentPageNumber = 0;

    private List<List<string>> Paginate(ref List<string> flatWordList, int pagesize = 100)
    {
        List<List<string>> retval = new List<List<string>>();

        int currentword = 0;
        retval.Add(new List<string>());
        int currentpage = 0;
        foreach (string word in flatWordList)
        {
            retval[currentpage].Add(word);
            currentword++;
            if ((currentword % pagesize) == 0) //we've reached pagesize
            {
                // TODO: see if we have any more words & don't add black pages
                retval.Add(new List<string>()); //Add another page
                currentpage++;
            }
        }

        return retval;
    }

    private string PageHeader
    {
        get
        {
            if (AllPages == null)
            {
                return string.Empty;
            }
            else
            {
                return "Page " + (CurrentPageNumber + 1).ToString() + " of " + AllPages.Count.ToString();
            }
        }
    }

    private void OnPageBack()
    {
        if (CurrentPageNumber <= 0 || AllPages == null) { return; }
        CurrentPageNumber--;
        CurrentPage = AllPages[CurrentPageNumber];
    }

    private void OnPageFwd()
    {
        if (AllPages == null || CurrentPageNumber >= AllPages.Count-1) { return; }
        CurrentPageNumber++;;
        CurrentPage = AllPages[CurrentPageNumber];
    }

    private async Task<bool> ReadWordsFile()
    {
        try
        {
            var foo = _client.GetStringAsync("words.txt");
            await foo;
            string[] wordsTemp = foo.Result.Split(',', StringSplitOptions.RemoveEmptyEntries);
            Wordlist.Clear();
            Wordlist = new List<string>(wordsTemp);
            AllPages = Paginate(ref Wordlist);
            CurrentPage = AllPages[CurrentPageNumber];
            Message = string.Empty;
            return true;
        }
        catch (Exception e)
        {
            Message = "Error loading word list.";
            Console.WriteLine(e.Message);
            Task failed = Task.CompletedTask;
            return false;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        Message = "Loading word list...";

        bool loadSuccess = await ReadWordsFile();
    }

    private string Message = string.Empty;

}